// Generated by LiveScript 1.5.0
(function(){
  var bitcoin, bip32utils, bip39, hdkey, waves, monero, network, buf2hex, getWavesFullpairByIndex, getMoneroFullpairByIndex, getBitcoinFullpairByIndex, getEthereumFullpairByIndex, getFullpairByIndex, getAddressByIndex, generateKeys, generateWallet, out$ = typeof exports != 'undefined' && exports || this;
  bitcoin = require('bitcoinjs-lib');
  bip32utils = require('bip32-utils');
  bip39 = require('bip39');
  hdkey = require('ethereumjs-wallet/hdkey');
  waves = require('waves.js/dist/waves.js');
  monero = require('./monero.js');
  network = bitcoin.networks.bitcoin;
  buf2hex = function(buffer){
    return Array.prototype.map.call(buffer, function(x){
      return ('00' + x.toString(16)).slice(-2);
    }).join('');
  };
  getWavesFullpairByIndex = function(mnemonic, index, network){
    var chainId, utils, ref$, address, keys, privateKey, publicKey;
    chainId = network.messagePrefix === 'Waves'
      ? 'W'.charCodeAt(0)
      : 'T'.charCodeAt(0);
    utils = new waves['default']({
      chainId: chainId
    });
    ref$ = utils.createAccount(mnemonic + " / " + index), address = ref$.address, keys = ref$.keys;
    privateKey = keys.privateKey, publicKey = keys.publicKey;
    return {
      address: address,
      privateKey: buf2hex(privateKey),
      publicKey: buf2hex(publicKey)
    };
  };
  getMoneroFullpairByIndex = function(mnemonic, index, network){
    var ref$, address, spendKey, viewKey;
    ref$ = monero.generateAddress(mnemonic + " / " + index), address = ref$.address, spendKey = ref$.spendKey, viewKey = ref$.viewKey;
    return {
      address: address,
      privateKey: spendKey,
      viewKey: viewKey
    };
  };
  getBitcoinFullpairByIndex = function(mnemonic, index, network){
    var seed, hdnode, address, privateKey;
    seed = bip39.mnemonicToSeedHex(mnemonic);
    hdnode = bitcoin.HDNode.fromSeedHex(seed, network).derive(index);
    address = hdnode.getAddress();
    privateKey = hdnode.keyPair.toWIF();
    return {
      address: address,
      privateKey: privateKey
    };
  };
  getEthereumFullpairByIndex = function(mnemonic, index, network){
    var seed, wallet, w, address, privateKey;
    seed = bip39.mnemonicToSeed(mnemonic);
    wallet = hdkey.fromMasterSeed(seed);
    w = wallet.derivePath("0").deriveChild(index).getWallet();
    address = "0x" + w.getAddress().toString('hex');
    privateKey = w.getPrivateKeyString();
    return {
      address: address,
      privateKey: privateKey
    };
  };
  out$.getFullpairByIndex = getFullpairByIndex = function(mnemonic, index, network){
    var type, fun;
    type = network != null ? network.messagePrefix : void 8;
    fun = (function(){
      switch (false) {
      case type != null:
        return "Wrong Type";
      case type !== 'Monero':
        return getMoneroFullpairByIndex;
      case !(type === 'Waves' || type === 'WavesTest'):
        return getWavesFullpairByIndex;
      case type !== 'Ethereum':
        return getEthereumFullpairByIndex;
      default:
        return getBitcoinFullpairByIndex;
      }
    }());
    return fun(mnemonic, index, network);
  };
  out$.getAddressByIndex = getAddressByIndex = function(mnemonic, index, network){
    return getFullPairByIndex(mnemonic, index, network).address;
  };
  out$.generateKeys = generateKeys = function(mnemonic){
    var seed, hdnode, privateKey, address, publicKey;
    seed = bip39.mnemonicToSeedHex(mnemonic);
    hdnode = bitcoin.HDNode.fromSeedHex(seed, network).derive(0);
    privateKey = hdnode.keyPair.toWIF();
    address = hdnode.getAddress();
    publicKey = hdnode.getPublicKeyBuffer().toString('hex');
    return {
      privateKey: privateKey,
      address: address,
      publicKey: publicKey
    };
  };
  out$.generateWallet = generateWallet = function(){
    var mnemonic, keys;
    mnemonic = bip39.generateMnemonic();
    keys = generateKeys(mnemonic);
    return {
      mnemonic: mnemonic,
      address: keys.address
    };
  };
}).call(this);
